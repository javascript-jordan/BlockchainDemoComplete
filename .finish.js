const { writeFileSync } = require("fs");
const { join } = require("path");

let blockchain = 'import * as database from \"..\/helpers\/database\";\r\nimport BlockchainBlock from \"..\/models\/Block\";\r\nimport { IBlockchainTransaction } from \"..\";\r\nimport BlockchainTransaction from \"..\/models\/Transaction\";\r\nimport { emit } from \"..\/socket\";\r\n\r\n\r\nconst TRANSACTIONS_PER_BLOCK: number = 5; \/\/amount of transactions allowed per block\r\nconst CURRENT_TRANSACTIONS: IBlockchainTransaction[] = []; \/\/temp transactions that havent been written\r\n\r\nexport const addTransaction = (type: string, data: any): BlockchainTransaction => {\r\n    \/\/spawn a new transaction\r\n    let transaction = new BlockchainTransaction(type, data);\r\n    \/\/add our transaction to the transactions array\r\n    CURRENT_TRANSACTIONS.push(transaction);\r\n    \/\/check to see if we need to write a new block\r\n    if(CURRENT_TRANSACTIONS.length === TRANSACTIONS_PER_BLOCK){\r\n        \/\/spawn a new block\r\n        let block = new BlockchainBlock([...CURRENT_TRANSACTIONS]);\r\n        \/\/insert the block into the Database\r\n        database.insert(\"blocks\", block);\r\n        \/\/empty current transaction array\r\n        CURRENT_TRANSACTIONS.length = 0;\r\n        \/\/emit a new block added event\r\n        emit(\"addNewBlock\", block);\r\n    }\r\n    \/\/return the new transaction\r\n    return transaction;\r\n}\r\n\r\n\/\/constructs the genesis block containing no transactions\r\n\/\/called on server startup in server.ts\r\nexport const constructGenesisBlock = (): void => {\r\n    \/\/new block passing no transactions\r\n    let block = new BlockchainBlock([]);\r\n    \/\/insert into database\r\n    database.insert(\"blocks\", block);\r\n}',
    block = 'import * as database from \"..\/helpers\/database\";\r\nimport { IBlockchainBlock, IBlockchainTransaction } from \"..\";\r\nimport { hash } from \"..\/helpers\/crypto\";\r\n\r\nexport default class BlockchainBlock implements IBlockchainBlock {\r\n\r\n    \/\/header containing previous blocks hash and a timestamp of creation date\r\n    header: { previousBlockHash: string, timestamp: number } = {} as any;\r\n    \/\/a list of transactions that will be stored on the block\r\n    transactions: IBlockchainTransaction[] = [];\r\n    \/\/the current height of the blockchain\r\n    height: number = null;\r\n    \/\/the current blocks hash\r\n    hash: string;\r\n\r\n    constructor(transactions: IBlockchainTransaction[]){\r\n        \/\/initialize the previous block hash by calculation with local method\r\n        this.header.previousBlockHash = this.calculatePreviousBlockHash();\r\n        \/\/create a new timestamp based on current date\r\n        this.header.timestamp = new Date().getTime();\r\n        \/\/calculate current height with local method\r\n        this.height = this.calculateBlockHeight();\r\n        \/\/initialize the transactions list with the one passed in by the caller\r\n        this.transactions = transactions;\r\n        \/\/get the hash of the current blocks data with local method\r\n        this.hash = this.createHashFromBlockData(this.height, this.header.timestamp, this.header.previousBlockHash, this.transactions);\r\n    }\r\n\r\n    private createHashFromBlockData(height: number, timestamp: number, previousBlockHash: string, transactions: any[]): string {\r\n        \/\/combine the block height, timestamp, previous block hash and the transactions to calculate the hash of the block\r\n        return hash(`${height}${timestamp}${previousBlockHash}${JSON.stringify(transactions)}`);\r\n    }\r\n\r\n    private calculateBlockHeight(): number {\r\n        \/\/checks the amount of current blocks in database and returns that as a number\r\n        return database.select(\"blocks\").length;\r\n    }\r\n\r\n    private calculatePreviousBlockHash(): string {\r\n        try {\r\n            \/\/first get a list of blocks from database\r\n            let blocks: IBlockchainBlock[] = database.select(\"blocks\"),\r\n                \/\/find the block that was appended last\r\n                block: IBlockchainBlock = JSON.parse(JSON.stringify(blocks.sort((a: any, b: any) => a.height < b.height ? -1 : 1)[blocks.length - 1]));\r\n            \/\/return the hash of the last blocks data\r\n            return this.createHashFromBlockData(block.height, block.header.timestamp, block.header.previousBlockHash, block.transactions);\r\n        } catch (error) {\r\n            \/\/if their was an error parsing data, return null\r\n            return null;\r\n        }\r\n    }\r\n}';

console.log(`Writing ${join(__dirname, "src/server/helpers/blockchain.ts")}`);
writeFileSync(join(__dirname, "src/server/helpers/blockchain.ts"), blockchain);
console.log(`Writing ${join(__dirname, "src/server/models/Block.ts")}`);
writeFileSync(join(__dirname, "src/server/models/Block.ts"), block);